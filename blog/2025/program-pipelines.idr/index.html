<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> Pipelined Programs Using Dependent Types | André Videla </title> <meta name="author" content="Andre Videla"> <meta name="description" content="A data structure to represent programming pipelines"> <meta name="keywords" content="Category theory, functional programming type theory, haskell, idris, scala, swift"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%E2%9A%9B%EF%B8%8F&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://andrevidela.com/blog/2025/program-pipelines.idr/"> <script src="/assets/js/theme.js?a5ca4084d3b81624bcfa01156dae2b8e"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>initTheme();</script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> André Videla </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about </a> </li> <li class="nav-item "> <a class="nav-link" href="/blog/">blog </a> </li> <li class="nav-item "> <a class="nav-link" href="/projects/">projects </a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">cv </a> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5" role="main"> <div class="post"> <header class="post-header"> <h1 class="post-title">Pipelined Programs Using Dependent Types</h1> <p class="post-meta"> January 11, 2025 </p> <p class="post-tags"> <a href="/blog/2025"> <i class="fa-solid fa-calendar fa-sm"></i> 2025 </a>   ·   <a href="/blog/tag/dependent-types"> <i class="fa-solid fa-hashtag fa-sm"></i> dependent-types</a>   <a href="/blog/tag/idris"> <i class="fa-solid fa-hashtag fa-sm"></i> idris</a>   <a href="/blog/tag/programming"> <i class="fa-solid fa-hashtag fa-sm"></i> programming</a>   <a href="/blog/tag/pipeline"> <i class="fa-solid fa-hashtag fa-sm"></i> pipeline</a>   </p> </header> <article class="post-content"> <div id="markdown-content"> <p>Sometimes, writing a large program is conceptually as simple as translating from a big unstructured input into a more and more structured output. A good example is a single-pass compiler:</p> <ul> <li>First we perform lexical analysis on a big string, this gives us a list of tokens.</li> <li>Then we parse the tokens into a tree.</li> <li>Then we do some semantic analysis on the tree, usually this involves some typechecking and error reporting</li> <li>Once we know what the program is, we generate code for it.</li> </ul> <h2 id="introducing-the-pipeline">Introducing the pipeline</h2> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/pipeline_illust_mid.PNG-480.webp 480w,/assets/img/pipeline_illust_mid.PNG-800.webp 800w,/assets/img/pipeline_illust_mid.PNG-1400.webp 1400w," sizes="95vw" type="image/webp"></source> <img src="/assets/img/pipeline_illust_mid.PNG" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <div class="caption"> An illustration of a pipeline with 4 layers and 3 stages. </div> <p>This structure is purely linear, and functional programmers will be delighted to point out that you can implement an entire compiler pipeline using nothing but function composition:</p> <div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">codegen</span> <span class="o">::</span> <span class="kt">Sema</span> <span class="o">-&gt;</span> <span class="kt">String</span>
<span class="n">typecheck</span> <span class="o">::</span> <span class="kt">Tree</span> <span class="o">-&gt;</span> <span class="kt">Sema</span>
<span class="n">parsing</span> <span class="o">::</span> <span class="p">[</span><span class="kt">Token</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="kt">Tree</span>
<span class="n">lexing</span> <span class="o">::</span> <span class="kt">String</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="kt">Token</span><span class="p">]</span>

<span class="n">compiler</span> <span class="o">::</span> <span class="kt">String</span> <span class="o">-&gt;</span> <span class="kt">String</span>
<span class="n">compiler</span> <span class="o">=</span> <span class="n">codegen</span> <span class="o">.</span> <span class="n">typecheck</span> <span class="o">.</span> <span class="n">parsing</span> <span class="o">.</span> <span class="n">lexing</span>
</code></pre></div></div> <p>Of course this is pure fantasy, there is no error reporting, no way to debug it, and no command line tool. But the core idea is compelling: what if there was a way to implement a compiler as a single pipeline of operation that clearly describes what each step achieves? For this, we’re going to define <em>pipelined programs</em> using Idris, because it uses dependent types, and it is reasonably fast and production ready. We define a <em>pipeline</em> as a list of <em>Types</em>, each type represents an intermediate stage.</p> <div class="language-idris highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">Pipeline :</span> <span class="kt">Nat </span><span class="o">-&gt;</span> <span class="kt">Type
Pipeline</span> <span class="n">length</span> <span class="o">=</span> <span class="kt">Vect</span> <span class="nb">length </span><span class="kt">Type
</span>
<span class="nf">CompilerPipeline :</span> <span class="kt">Pipeline</span> <span class="o">?</span>
<span class="kt">CompilerPipeline</span> <span class="o">=</span>
  <span class="p">[</span> <span class="kt">String</span>
  <span class="p">,</span> <span class="kt">List Token</span>
  <span class="p">,</span> <span class="kt">Tree</span>
  <span class="p">,</span> <span class="kt">Sema</span>
  <span class="p">,</span> <span class="kt">String</span>
  <span class="p">]</span>
</code></pre></div></div> <p>With it, we define a <em>compiler pipeline</em> as the list of types <code class="language-plaintext highlighter-rouge">String</code>, <code class="language-plaintext highlighter-rouge">List Token</code>, <code class="language-plaintext highlighter-rouge">Tree</code>, <code class="language-plaintext highlighter-rouge">Sema</code>, and <code class="language-plaintext highlighter-rouge">String</code>, representing all the stages of our compiler.</p> <p>The pipeline is indexed by it length to ensure that our pipeline is valid, since we need a type from which we start, and a type to which we arrive. Using this fact we can define the <em>implementation</em> for a pipeline.</p> <div class="language-idris highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- Well formed pipelines have at least 2 elements, the start and the end type</span>
<span class="nf">Impl :</span> <span class="kt">Pipeline</span> <span class="p">(</span><span class="mf">2</span> <span class="o">+</span> <span class="n">n</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Type
Impl</span> <span class="p">(</span><span class="n">x</span> <span class="o">::</span> <span class="n">y</span> <span class="o">::</span> <span class="kt">[]</span><span class="p">)</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">y</span>
<span class="kt">Impl</span> <span class="p">(</span><span class="n">x</span> <span class="o">::</span> <span class="n">y</span> <span class="o">::</span> <span class="n">z</span> <span class="o">::</span> <span class="n">xs</span><span class="p">)</span> <span class="o">=</span> <span class="kt">Pair</span> <span class="p">(</span><span class="n">x</span> <span class="o">-&gt;</span> <span class="n">y</span><span class="p">)</span> <span class="p">(</span><span class="kt">Impl</span> <span class="p">(</span><span class="n">y</span> <span class="o">::</span> <span class="n">z</span> <span class="o">::</span> <span class="n">xs</span><span class="p">))</span>
</code></pre></div></div> <p>We can test our implementation by asking in the REPL what is a valid implementation of out compiler pipeline.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; Impl CompilerPipeline
&lt; (String -&gt; List Token, (List Token -&gt; Tree, (Tree -&gt; Sema, Sema -&gt; String)))
</code></pre></div></div> <p>This is a 4-tuples of functions <code class="language-plaintext highlighter-rouge">String -&gt; List Token</code>, <code class="language-plaintext highlighter-rouge">List Token -&gt; Tree</code>, <code class="language-plaintext highlighter-rouge">Tree -&gt; Sema</code> and <code class="language-plaintext highlighter-rouge">Sema -&gt; String</code>, exactly what we wanted.</p> <p>Now that <code class="language-plaintext highlighter-rouge">Impl</code> correctly gives us the type of an appropriate implementation for a pipeline, we still need to <em>run</em> the pipeline. Running the pipeline should amount to using function composition on each of the functions. Unfortunately it’s not that easy because each intermediate step uses a different type and we can’t just blindly apply a function without knowing its type.</p> <p>Like before, to run a <code class="language-plaintext highlighter-rouge">Pipeline</code>, it needs at least two elements. Running a pipeline should result in a simple function from the first layer of the pipeline to the last one. To write this we use the function <code class="language-plaintext highlighter-rouge">head</code> and <code class="language-plaintext highlighter-rouge">last</code> from <code class="language-plaintext highlighter-rouge">Data.Vect</code> those functions do exactly what you expect from their name but here we call them to define the type of the function that will result from running the pipeline.</p> <div class="language-idris highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- When we run the pipeline `p` we expect to get out a function `head p -&gt; last `p`,</span>
<span class="c1">-- that is, the first stage of the pipeline as the argument of the function and the</span>
<span class="c1">-- last stage as the result of it.</span>
<span class="nf">Run :</span> <span class="p">(</span><span class="n">p</span> <span class="o">:</span> <span class="kt">Pipeline</span> <span class="p">(</span><span class="mf">2</span> <span class="o">+</span> <span class="n">n</span><span class="p">))</span> <span class="o">-&gt;</span> <span class="kt">Impl</span> <span class="n">p</span> <span class="o">-&gt;</span> <span class="nb">head </span><span class="n">p</span> <span class="o">-&gt;</span> <span class="nb">last </span><span class="n">p</span>
<span class="kt">Run</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="n">f</span> <span class="o">=</span> <span class="n">f</span>
<span class="kt">Run</span> <span class="p">(</span><span class="n">s</span> <span class="o">::</span> <span class="n">t</span> <span class="o">::</span> <span class="n">x</span> <span class="o">::</span> <span class="n">xs</span><span class="p">)</span> <span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">cont</span><span class="p">)</span> <span class="o">=</span> <span class="kt">Run</span> <span class="p">(</span><span class="n">t</span> <span class="o">::</span> <span class="n">x</span> <span class="o">::</span> <span class="n">xs</span><span class="p">)</span> <span class="n">cont</span> <span class="o">.</span> <span class="n">f</span>
</code></pre></div></div> <p>The base case runs the single stage we have with the argument we’re given. The inductive case run the remaining of the pipeline on the result of the stage we are on right now <code class="language-plaintext highlighter-rouge">f</code> is the stage and <code class="language-plaintext highlighter-rouge">v</code> is the value given as argument to the pipeline.</p> <p>We can test this idea by assuming we have functions <code class="language-plaintext highlighter-rouge">lex</code>, <code class="language-plaintext highlighter-rouge">parse</code>, <code class="language-plaintext highlighter-rouge">typecheck</code> and <code class="language-plaintext highlighter-rouge">codegen</code> like in the haskell example and see what happens:</p> <div class="language-idris highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">lex :</span> <span class="kt">String</span> <span class="o">-&gt;</span> <span class="kt">List Token</span>
<span class="nf">parse :</span> <span class="kt">List Token</span> <span class="o">-&gt;</span> <span class="kt">Tree</span>
<span class="nf">typecheck :</span> <span class="kt">Tree</span> <span class="o">-&gt;</span> <span class="kt">Sema</span>
<span class="nf">codegen :</span> <span class="kt">Sema</span> <span class="o">-&gt;</span> <span class="kt">String</span>

<span class="nf">runCompiler :</span> <span class="kt">String</span> <span class="o">-&gt;</span> <span class="kt">String</span>
<span class="n">runCompiler</span> <span class="o">=</span> <span class="kt">Run</span> <span class="kt">CompilerPipeline</span> <span class="p">(</span><span class="n">lex</span><span class="p">,</span> <span class="n">parse</span><span class="p">,</span> <span class="n">typecheck</span><span class="p">,</span> <span class="n">codegen</span><span class="p">)</span>
</code></pre></div></div> <p>And it typechecks! We cannot run this code because we don’t have an implementation for <code class="language-plaintext highlighter-rouge">lex</code>, <code class="language-plaintext highlighter-rouge">parse</code>, etc, but we’ve at least reached our goal: to build a datastructure that help us keep track of what are the stages in our pipeline.</p> <h2 id="handling-effects">Handling effects</h2> <p>This is quite cool, but it’s not the end. Remember that compiler need to perform a lot of side effects, returning errors, sometime print out intermediate trees for debugging, how does the pipeline help for that?</p> <p>Well the great benefit from the pipeline is that we’ve separated the information about the stages from the information about the runtime implementation of the stages. This information is created by <code class="language-plaintext highlighter-rouge">Impl</code> which create the type of an implementation given a pipeline, but this current version only places the types end-to-end without changes. What if we add an extra <code class="language-plaintext highlighter-rouge">Monad</code> around the types such that instead of functions <code class="language-plaintext highlighter-rouge">a -&gt; b</code>, each stage is now an effectful function <code class="language-plaintext highlighter-rouge">a -&gt; m b</code>.</p> <p>First we define <code class="language-plaintext highlighter-rouge">m : Type -&gt; Type</code>, our monad, we use a parameter block because we will use it for running our programs too.</p> <div class="language-idris highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">parameters</span> <span class="p">{</span><span class="mf">0</span> <span class="n">m</span> <span class="o">:</span> <span class="kt">Type </span><span class="o">-&gt;</span> <span class="kt">Type</span><span class="p">}</span>
</code></pre></div></div> <p>Then, in the implementation, we use the same type signature, but in the base-case, instead of returning <code class="language-plaintext highlighter-rouge">x -&gt; y</code>, we return <code class="language-plaintext highlighter-rouge">x -&gt; m y</code>. And similarly with the inductive case.</p> <div class="language-idris highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="mf">0</span>
  <span class="kt">ImplM</span> <span class="o">:</span> <span class="kt">Pipeline</span> <span class="p">(</span><span class="mf">2</span> <span class="o">+</span> <span class="n">n</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Type
</span>  <span class="kt">ImplM</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="n">y</span>
  <span class="kt">ImplM</span> <span class="p">(</span><span class="n">x</span> <span class="o">::</span> <span class="n">y</span> <span class="o">::</span> <span class="n">z</span> <span class="o">::</span> <span class="n">xs</span><span class="p">)</span> <span class="o">=</span> <span class="kt">Pair</span> <span class="p">(</span><span class="n">x</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="n">y</span><span class="p">)</span> <span class="p">(</span><span class="kt">ImplM</span> <span class="p">(</span><span class="n">y</span> <span class="o">::</span> <span class="n">z</span> <span class="o">::</span> <span class="n">xs</span><span class="p">))</span>
</code></pre></div></div> <p>Like before, we now test <code class="language-plaintext highlighter-rouge">ImplM</code> in the repl with a monad <code class="language-plaintext highlighter-rouge">Maybe</code> and we get:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; ImplM {m = Maybe} CompilerPipeline
&lt; (String -&gt; Maybe (List Token), (List Token -&gt; Maybe Tree, (Tree -&gt; Maybe Sema, Sema -&gt; Maybe String)))
</code></pre></div></div> <p>And that is precisely what we expected, now every stage runs in a <code class="language-plaintext highlighter-rouge">Maybe</code> monad, and we could replace this monad by anything else and obtain all sorts of effects. Now remains to run a pipeline with effects using our effectful implementation. The type looks like <code class="language-plaintext highlighter-rouge">Run</code> but we make use of <em>kleisli</em> composition instead of function composition.</p> <div class="language-idris highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kt">RunM</span> <span class="o">:</span> <span class="p">(</span><span class="n">mon</span> <span class="o">:</span> <span class="nc">Monad </span><span class="n">m</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">(</span><span class="n">p</span> <span class="o">:</span> <span class="kt">Pipeline</span> <span class="p">(</span><span class="mf">2</span> <span class="o">+</span> <span class="n">n</span><span class="p">))</span> <span class="o">-&gt;</span> <span class="kt">ImplM</span> <span class="n">p</span> <span class="o">-&gt;</span> <span class="kt">Vect</span><span class="o">.</span><span class="nb">head </span><span class="n">p</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="p">(</span><span class="kt">Vect</span><span class="o">.</span><span class="nb">last </span><span class="n">p</span><span class="p">)</span>
  <span class="kt">RunM</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span>  <span class="n">f</span> <span class="o">=</span> <span class="n">f</span>
  <span class="kt">RunM</span> <span class="p">(</span><span class="n">x</span> <span class="o">::</span> <span class="n">y</span> <span class="o">::</span> <span class="n">z</span> <span class="o">::</span> <span class="n">xs</span><span class="p">)</span> <span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="o">=</span> <span class="n">f</span> <span class="o">&gt;=&gt;</span> <span class="kt">RunM</span> <span class="p">(</span><span class="n">y</span> <span class="o">::</span> <span class="n">z</span> <span class="o">::</span> <span class="n">xs</span><span class="p">)</span> <span class="n">c</span>
</code></pre></div></div> <p>To run the compiler, each stage needs to perform an effect, here we’re using <code class="language-plaintext highlighter-rouge">Either String</code> to represent errors:</p> <div class="language-idris highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">namespace</span> <span class="kt">EffectfulCompiler</span>
  <span class="n">lex</span> <span class="o">:</span> <span class="kt">String</span> <span class="o">-&gt;</span> <span class="kt">Either String</span> <span class="p">(</span><span class="kt">List Token</span><span class="p">)</span>
  <span class="n">parse</span> <span class="o">:</span> <span class="kt">List Token</span> <span class="o">-&gt;</span> <span class="kt">Either String</span> <span class="kt">Tree</span>
  <span class="n">typecheck</span> <span class="o">:</span> <span class="kt">Tree</span> <span class="o">-&gt;</span> <span class="kt">Either String</span> <span class="kt">Sema</span>
  <span class="n">codegen</span> <span class="o">:</span> <span class="kt">Sema</span> <span class="o">-&gt;</span> <span class="kt">Either String</span> <span class="kt">String</span>

  <span class="n">runCompiler</span> <span class="o">:</span> <span class="kt">String</span> <span class="o">-&gt;</span> <span class="kt">Either String</span> <span class="kt">String</span>
  <span class="n">runCompiler</span> <span class="o">=</span> <span class="kt">RunM</span> <span class="kt">CompilerPipeline</span> <span class="p">(</span><span class="n">lex</span><span class="p">,</span> <span class="n">parse</span><span class="p">,</span> <span class="n">typecheck</span><span class="p">,</span> <span class="n">codegen</span><span class="p">)</span>
</code></pre></div></div> <p>Crucially, we’ve not changed the pipeline at all! We’ve only changed how to interpret it as a runtime program.</p> <h2 id="debugging-programs">Debugging programs</h2> <p>Finally, using the same datastructure we can run our pipeline in <em>debug mode</em>. This mode will print in the terminal all the intermediate steps so that you can see what is happening at each stage. For this to work, we need to make sure that, for all layers in the pipeline, we have a way to <em>print</em> the result of the computation, we achieve this with the <code class="language-plaintext highlighter-rouge">All : (ty -&gt; Type) -&gt; Vect n ty -&gt; Type</code> type which takes a list of elements and a predicate over that list, and describes a list of proofs that ensure the predicate hold for every value of <code class="language-plaintext highlighter-rouge">ty</code> given. In our case, the predicate given is the <code class="language-plaintext highlighter-rouge">Show</code> interface, and so for each type there must exist a <code class="language-plaintext highlighter-rouge">Show</code> instance.</p> <p>The rest of the function is the same as before, except we compose each <code class="language-plaintext highlighter-rouge">f</code> with <code class="language-plaintext highlighter-rouge">pure . traceValBy show</code> to print the value we just computed.</p> <div class="language-idris highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">RunTraceM :</span> <span class="nc">Monad </span><span class="n">m</span> <span class="o">=&gt;</span> <span class="p">(</span><span class="n">p</span> <span class="o">:</span> <span class="kt">Pipeline</span> <span class="p">(</span><span class="mf">2</span> <span class="o">+</span> <span class="n">n</span><span class="p">))</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">print</span> <span class="o">:</span> <span class="kt">All</span> <span class="kt">Show</span> <span class="n">p</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="kt">ImplM</span> <span class="p">{</span><span class="n">m</span><span class="p">}</span> <span class="n">p</span> <span class="o">-&gt;</span> <span class="kt">Vect</span><span class="o">.</span><span class="nb">head </span><span class="n">p</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="p">(</span><span class="kt">Vect</span><span class="o">.</span><span class="nb">last </span><span class="n">p</span><span class="p">)</span>
<span class="kt">RunTraceM</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="p">{</span><span class="n">print</span> <span class="o">=</span> <span class="p">[</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">]}</span> <span class="n">f</span> <span class="o">=</span> <span class="n">f</span> <span class="o">&gt;=&gt;</span> <span class="n">pure</span> <span class="o">.</span> <span class="n">traceValBy</span> <span class="n">show</span>
<span class="kt">RunTraceM</span> <span class="p">(</span><span class="n">x</span> <span class="o">::</span> <span class="n">y</span> <span class="o">::</span> <span class="n">z</span> <span class="o">::</span> <span class="n">xs</span><span class="p">)</span> <span class="p">{</span><span class="n">print</span> <span class="o">=</span> <span class="n">p</span> <span class="o">::</span> <span class="n">q</span> <span class="o">::</span> <span class="n">ps</span><span class="p">}</span> <span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="o">=</span>
  <span class="n">f</span> <span class="o">&gt;=&gt;</span> <span class="n">pure</span> <span class="o">.</span> <span class="n">traceValBy</span> <span class="nb">show </span><span class="o">&gt;=&gt;</span> <span class="kt">RunTraceM</span> <span class="p">(</span><span class="n">y</span> <span class="o">::</span> <span class="n">z</span> <span class="o">::</span> <span class="n">xs</span><span class="p">)</span> <span class="n">c</span>
</code></pre></div></div> <h2 id="conclusion">Conclusion</h2> <p>We’re not done yet but this is already more than we can usually do without dependent types. We can take the pipeline and build multiple runtimes for it. I’ve not shown it here but we can also implement operations on the pipeline like concatenation, splicing, etc. Those operations should reflect what happens at runtime: Concatenating two pipeline should compose two programs that run them. There is a lot more to say about this topic but that will do for now, see you in the next one.</p> </div> </article> <br> <hr> <br> <ul class="list-disc pl-8"></ul> <h2 class="text-3xl font-semibold mb-4 mt-12">Enjoy Reading This Article?</h2> <p class="mb-2">Here are some more articles you might like to read next:</p> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2024/govan-active-travel/">Govan Active Travel</a> </li> </div> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2025 Andre Videla. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js" integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script src="/assets/js/no_defer.js?2781658a0a2b13ed609542042a859126"></script> <script defer src="/assets/js/common.js?b7816bd189846d29eded8745f9c4cf77"></script> <script defer src="/assets/js/copy_code.js?12775fdf7f95e901d7119054556e495f" type="text/javascript"></script> <script defer src="/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.min.js"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>