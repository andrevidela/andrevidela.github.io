<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.4">Jekyll</generator><link href="https://andrevidela.com/feed.xml" rel="self" type="application/atom+xml"/><link href="https://andrevidela.com/" rel="alternate" type="text/html" hreflang="en"/><updated>2025-01-13T11:09:12+00:00</updated><id>https://andrevidela.com/feed.xml</id><title type="html">André Videla</title><subtitle>Welcome to my personal website, where you will find everything that I do, that I&apos;ve done, and that I&apos;m working on. </subtitle><entry><title type="html">Programing Pipelines Using Dependent Types</title><link href="https://andrevidela.com/blog/2025/program-pipelines.idr/" rel="alternate" type="text/html" title="Programing Pipelines Using Dependent Types"/><published>2025-01-11T14:57:00+00:00</published><updated>2025-01-11T14:57:00+00:00</updated><id>https://andrevidela.com/blog/2025/program-pipelines.idr</id><content type="html" xml:base="https://andrevidela.com/blog/2025/program-pipelines.idr/"><![CDATA[ <p>Sometimes, writing a large program is conceptually as simple as translating from a big unstructured input into a more and more structured output. A good example is a single-pass compiler:</p> <ul> <li>First we perform lexical analysis on a big string, this gives us a list of tokens.</li> <li>Then we parse the tokens into a tree.</li> <li>Then we do some semantic analysis on the tree, usually this involves some typechecking and error reporting</li> <li>Once we know what the program is, we generate code for it.</li> </ul> <h2 id="introducing-the-pipeline">Introducing the pipeline</h2> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/pipeline_illust_mid-480.webp 480w,/assets/img/pipeline_illust_mid-800.webp 800w,/assets/img/pipeline_illust_mid-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/pipeline_illust_mid.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <div class="caption"> An illustration of a pipeline with 4 layers and 3 stages. </div> <p>This structure is purely linear, and functional programmers will be delighted to point out that you can implement an entire compiler pipeline using nothing but function composition:</p> <div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">codegen</span> <span class="o">::</span> <span class="kt">Sema</span> <span class="o">-&gt;</span> <span class="kt">String</span>
<span class="n">typecheck</span> <span class="o">::</span> <span class="kt">Tree</span> <span class="o">-&gt;</span> <span class="kt">Sema</span>
<span class="n">parsing</span> <span class="o">::</span> <span class="p">[</span><span class="kt">Token</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="kt">Tree</span>
<span class="n">lexing</span> <span class="o">::</span> <span class="kt">String</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="kt">Token</span><span class="p">]</span>

<span class="n">compiler</span> <span class="o">::</span> <span class="kt">String</span> <span class="o">-&gt;</span> <span class="kt">String</span>
<span class="n">compiler</span> <span class="o">=</span> <span class="n">codegen</span> <span class="o">.</span> <span class="n">typecheck</span> <span class="o">.</span> <span class="n">parsing</span> <span class="o">.</span> <span class="n">lexing</span>
</code></pre></div></div> <p>Of course this is pure fantasy, there is no error reporting, no way to debug it, and no command line tool. But the core idea is compelling: what if there was a way to implement a compiler as a single pipeline of operation that clearly describes what each step achieves? For this, we’re going to define <em>pipelined programs</em> using Idris, because it uses dependent types, and it is reasonably fast and production ready. We define a <em>pipeline</em> as a list of <em>Types</em>, each type represents an intermediate layer.</p> <div class="language-idris highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">Pipeline :</span> <span class="kt">Nat </span><span class="o">-&gt;</span> <span class="kt">Type
Pipeline</span> <span class="n">length</span> <span class="o">=</span> <span class="kt">Vect</span> <span class="nb">length </span><span class="kt">Type
</span>
<span class="nf">CompilerPipeline :</span> <span class="kt">Pipeline</span> <span class="o">?</span>
<span class="kt">CompilerPipeline</span> <span class="o">=</span>
  <span class="p">[</span> <span class="kt">String</span>
  <span class="p">,</span> <span class="kt">List Token</span>
  <span class="p">,</span> <span class="kt">Tree</span>
  <span class="p">,</span> <span class="kt">Sema</span>
  <span class="p">,</span> <span class="kt">String</span>
  <span class="p">]</span>
</code></pre></div></div> <p>With it, we define a <em>compiler pipeline</em> as the list of types <code class="language-plaintext highlighter-rouge">String</code>, <code class="language-plaintext highlighter-rouge">List Token</code>, <code class="language-plaintext highlighter-rouge">Tree</code>, <code class="language-plaintext highlighter-rouge">Sema</code>, and <code class="language-plaintext highlighter-rouge">String</code>, representing all the stages of our compiler.</p> <p>The pipeline is indexed by it length, to ensure that our pipeline is valid this length needs to be at least 2, since we need a type from which we start, and a type to which we arrive. Using this fact we can define the <em>implementation</em> for a pipeline.</p> <div class="language-idris highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- Well formed pipelines have at least 2 elements, the start and the end type</span>
<span class="nf">Impl :</span> <span class="kt">Pipeline</span> <span class="p">(</span><span class="mf">2</span> <span class="o">+</span> <span class="n">n</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Type
Impl</span> <span class="p">(</span><span class="n">x</span> <span class="o">::</span> <span class="n">y</span> <span class="o">::</span> <span class="kt">[]</span><span class="p">)</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">y</span>
<span class="kt">Impl</span> <span class="p">(</span><span class="n">x</span> <span class="o">::</span> <span class="n">y</span> <span class="o">::</span> <span class="n">z</span> <span class="o">::</span> <span class="n">xs</span><span class="p">)</span> <span class="o">=</span> <span class="kt">Pair</span> <span class="p">(</span><span class="n">x</span> <span class="o">-&gt;</span> <span class="n">y</span><span class="p">)</span> <span class="p">(</span><span class="kt">Impl</span> <span class="p">(</span><span class="n">y</span> <span class="o">::</span> <span class="n">z</span> <span class="o">::</span> <span class="n">xs</span><span class="p">))</span>
</code></pre></div></div> <p>We can test our implementation by asking in the REPL what is a valid implementation of out compiler pipeline.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; Impl CompilerPipeline
&lt; (String -&gt; List Token, (List Token -&gt; Tree, (Tree -&gt; Sema, Sema -&gt; String)))
</code></pre></div></div> <p>This is a 4-tuple of functions <code class="language-plaintext highlighter-rouge">String -&gt; List Token</code>, <code class="language-plaintext highlighter-rouge">List Token -&gt; Tree</code>, <code class="language-plaintext highlighter-rouge">Tree -&gt; Sema</code> and <code class="language-plaintext highlighter-rouge">Sema -&gt; String</code>, exactly what we wanted, each of those function represents a stage in our compiler.</p> <p>Now that <code class="language-plaintext highlighter-rouge">Impl</code> correctly gives us the type of an appropriate implementation for a pipeline, we still need to <em>run</em> the pipeline. Running the pipeline should amount to using function composition on each of the functions. Unfortunately it’s not that easy because each intermediate step uses a different type and we can’t just blindly apply a function without knowing its type.</p> <p>Like before, to run a <code class="language-plaintext highlighter-rouge">Pipeline</code>, it needs at least two elements. Running a pipeline should result in a simple function from the first layer of the pipeline to the last one. To write this we use the function <code class="language-plaintext highlighter-rouge">head</code> and <code class="language-plaintext highlighter-rouge">last</code> from <code class="language-plaintext highlighter-rouge">Data.Vect</code> those functions do exactly what you expect from their name but here we call them to define the type of the function that will result from running the pipeline.</p> <div class="language-idris highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- When we run the pipeline `p` we expect to get out a function `head p -&gt; last `p`,</span>
<span class="c1">-- that is, the first stage of the pipeline as the argument of the function and the</span>
<span class="c1">-- last stage as the result of it.</span>
<span class="nf">Run :</span> <span class="p">(</span><span class="n">p</span> <span class="o">:</span> <span class="kt">Pipeline</span> <span class="p">(</span><span class="mf">2</span> <span class="o">+</span> <span class="n">n</span><span class="p">))</span> <span class="o">-&gt;</span> <span class="kt">Impl</span> <span class="n">p</span> <span class="o">-&gt;</span> <span class="nb">head </span><span class="n">p</span> <span class="o">-&gt;</span> <span class="nb">last </span><span class="n">p</span>
<span class="c1">-- In the base case, the pipeline contains only one stage x -&gt; y so we return it</span>
<span class="kt">Run</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="n">f</span> <span class="o">=</span> <span class="n">f</span>
<span class="c1">-- In the inductive case, we compose `f` with the rest of the pipeline</span>
<span class="kt">Run</span> <span class="p">(</span><span class="n">s</span> <span class="o">::</span> <span class="n">t</span> <span class="o">::</span> <span class="n">x</span> <span class="o">::</span> <span class="n">xs</span><span class="p">)</span> <span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">cont</span><span class="p">)</span> <span class="o">=</span> <span class="kt">Run</span> <span class="p">(</span><span class="n">t</span> <span class="o">::</span> <span class="n">x</span> <span class="o">::</span> <span class="n">xs</span><span class="p">)</span> <span class="n">cont</span> <span class="o">.</span> <span class="n">f</span>
</code></pre></div></div> <p>The base case runs the single stage we have with the argument we’re given. The inductive case run the remaining of the pipeline after running the current stage represented by the function <code class="language-plaintext highlighter-rouge">f</code>.</p> <p>We can test this idea by assuming we have functions <code class="language-plaintext highlighter-rouge">lex</code>, <code class="language-plaintext highlighter-rouge">parse</code>, <code class="language-plaintext highlighter-rouge">typecheck</code> and <code class="language-plaintext highlighter-rouge">codegen</code> like in the haskell example and see what happens:</p> <div class="language-idris highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">lex :</span> <span class="kt">String</span> <span class="o">-&gt;</span> <span class="kt">List Token</span>
<span class="nf">parse :</span> <span class="kt">List Token</span> <span class="o">-&gt;</span> <span class="kt">Tree</span>
<span class="nf">typecheck :</span> <span class="kt">Tree</span> <span class="o">-&gt;</span> <span class="kt">Sema</span>
<span class="nf">codegen :</span> <span class="kt">Sema</span> <span class="o">-&gt;</span> <span class="kt">String</span>

<span class="nf">runCompiler :</span> <span class="kt">String</span> <span class="o">-&gt;</span> <span class="kt">String</span>
<span class="n">runCompiler</span> <span class="o">=</span> <span class="kt">Run</span> <span class="kt">CompilerPipeline</span> <span class="p">(</span><span class="n">lex</span><span class="p">,</span> <span class="n">parse</span><span class="p">,</span> <span class="n">typecheck</span><span class="p">,</span> <span class="n">codegen</span><span class="p">)</span>
</code></pre></div></div> <p>And it typechecks! We cannot run this code because we don’t have an implementation for <code class="language-plaintext highlighter-rouge">lex</code>, <code class="language-plaintext highlighter-rouge">parse</code>, etc, but we’ve at least reached our goal: to build a datastructure that help us keep track of what are the stages in our pipeline.</p> <h2 id="handling-effects">Handling effects</h2> <p>This is quite cool, but it’s not the end. Remember that compiler need to perform a lot of side effects, returning errors, sometime print out intermediate trees for debugging, how does the pipeline help for that?</p> <p>Well the great benefit from the pipeline is that we’ve separated the information about the stages from the information about the runtime implementation of the stages. This information is created by <code class="language-plaintext highlighter-rouge">Impl</code> which create the type of an implementation given a pipeline, but this current version only places the types end-to-end without changes. What if we add an extra <code class="language-plaintext highlighter-rouge">Monad</code> around the types such that instead of functions <code class="language-plaintext highlighter-rouge">a -&gt; b</code>, each stage is now an effectful function <code class="language-plaintext highlighter-rouge">a -&gt; m b</code>.</p> <p>First we define <code class="language-plaintext highlighter-rouge">m : Type -&gt; Type</code>, our monad, we use a parameter block because we will use it for running our programs too.</p> <div class="language-idris highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">parameters</span> <span class="p">{</span><span class="mf">0</span> <span class="n">m</span> <span class="o">:</span> <span class="kt">Type </span><span class="o">-&gt;</span> <span class="kt">Type</span><span class="p">}</span>
</code></pre></div></div> <p>Then, in the implementation, we use the same type signature, but in the base-case, instead of returning <code class="language-plaintext highlighter-rouge">x -&gt; y</code>, we return <code class="language-plaintext highlighter-rouge">x -&gt; m y</code>. And similarly with the inductive case.</p> <div class="language-idris highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="mf">0</span>
  <span class="kt">ImplM</span> <span class="o">:</span> <span class="kt">Pipeline</span> <span class="p">(</span><span class="mf">2</span> <span class="o">+</span> <span class="n">n</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Type
</span>  <span class="kt">ImplM</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="n">y</span>
  <span class="kt">ImplM</span> <span class="p">(</span><span class="n">x</span> <span class="o">::</span> <span class="n">y</span> <span class="o">::</span> <span class="n">z</span> <span class="o">::</span> <span class="n">xs</span><span class="p">)</span> <span class="o">=</span> <span class="kt">Pair</span> <span class="p">(</span><span class="n">x</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="n">y</span><span class="p">)</span> <span class="p">(</span><span class="kt">ImplM</span> <span class="p">(</span><span class="n">y</span> <span class="o">::</span> <span class="n">z</span> <span class="o">::</span> <span class="n">xs</span><span class="p">))</span>
</code></pre></div></div> <p>Like before, we now test <code class="language-plaintext highlighter-rouge">ImplM</code> in the repl with a monad <code class="language-plaintext highlighter-rouge">Maybe</code> and we get:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; ImplM {m = Maybe} CompilerPipeline
&lt; (String -&gt; Maybe (List Token), (List Token -&gt; Maybe Tree, (Tree -&gt; Maybe Sema, Sema -&gt; Maybe String)))
</code></pre></div></div> <p>Now every stage runs in a <code class="language-plaintext highlighter-rouge">Maybe</code> monad, and we could replace this monad by anything else and obtain all sorts of effects. It remains to run a pipeline with effects using our effectful implementation. We implement a function just like <code class="language-plaintext highlighter-rouge">Run</code> but we make use of <em>kleisli</em> composition instead of function composition.</p> <div class="language-idris highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kt">RunM</span> <span class="o">:</span> <span class="p">(</span><span class="n">mon</span> <span class="o">:</span> <span class="nc">Monad </span><span class="n">m</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">(</span><span class="n">p</span> <span class="o">:</span> <span class="kt">Pipeline</span> <span class="p">(</span><span class="mf">2</span> <span class="o">+</span> <span class="n">n</span><span class="p">))</span> <span class="o">-&gt;</span> <span class="kt">ImplM</span> <span class="n">p</span> <span class="o">-&gt;</span> <span class="kt">Vect</span><span class="o">.</span><span class="nb">head </span><span class="n">p</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="p">(</span><span class="kt">Vect</span><span class="o">.</span><span class="nb">last </span><span class="n">p</span><span class="p">)</span>
  <span class="kt">RunM</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span>  <span class="n">f</span> <span class="o">=</span> <span class="n">f</span>
  <span class="kt">RunM</span> <span class="p">(</span><span class="n">x</span> <span class="o">::</span> <span class="n">y</span> <span class="o">::</span> <span class="n">z</span> <span class="o">::</span> <span class="n">xs</span><span class="p">)</span> <span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="o">=</span> <span class="n">f</span> <span class="o">&gt;=&gt;</span> <span class="kt">RunM</span> <span class="p">(</span><span class="n">y</span> <span class="o">::</span> <span class="n">z</span> <span class="o">::</span> <span class="n">xs</span><span class="p">)</span> <span class="n">c</span>
</code></pre></div></div> <p>To run the compiler, each stage needs to perform an effect, here we’re using <code class="language-plaintext highlighter-rouge">Either String</code> to represent errors:</p> <div class="language-idris highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">namespace</span> <span class="kt">EffectfulCompiler</span>
  <span class="n">lex</span> <span class="o">:</span> <span class="kt">String</span> <span class="o">-&gt;</span> <span class="kt">Either String</span> <span class="p">(</span><span class="kt">List Token</span><span class="p">)</span>
  <span class="n">parse</span> <span class="o">:</span> <span class="kt">List Token</span> <span class="o">-&gt;</span> <span class="kt">Either String</span> <span class="kt">Tree</span>
  <span class="n">typecheck</span> <span class="o">:</span> <span class="kt">Tree</span> <span class="o">-&gt;</span> <span class="kt">Either String</span> <span class="kt">Sema</span>
  <span class="n">codegen</span> <span class="o">:</span> <span class="kt">Sema</span> <span class="o">-&gt;</span> <span class="kt">Either String</span> <span class="kt">String</span>

  <span class="n">runCompiler</span> <span class="o">:</span> <span class="kt">String</span> <span class="o">-&gt;</span> <span class="kt">Either String</span> <span class="kt">String</span>
  <span class="n">runCompiler</span> <span class="o">=</span> <span class="kt">RunM</span> <span class="kt">CompilerPipeline</span> <span class="p">(</span><span class="n">lex</span><span class="p">,</span> <span class="n">parse</span><span class="p">,</span> <span class="n">typecheck</span><span class="p">,</span> <span class="n">codegen</span><span class="p">)</span>
</code></pre></div></div> <p>Crucially, we’ve not changed the pipeline at all! We’ve only changed how to interpret it as a runtime program.</p> <h2 id="debugging-programs">Debugging programs</h2> <p>Finally, using the same datastructure we can run our pipeline in <em>debug mode</em>. This mode will print in the terminal all the intermediate steps so that you can see what is happening at each stage. For this to work, we need to make sure that, for all layers in the pipeline, we have a way to <em>print</em> the result of the computation, we achieve this with the <code class="language-plaintext highlighter-rouge">All : (ty -&gt; Type) -&gt; Vect n ty -&gt; Type</code> type which takes a list of elements and a predicate over that list, and describes a list of proofs that ensure the predicate hold for every value of <code class="language-plaintext highlighter-rouge">ty</code> given. In our case, the predicate given is the <code class="language-plaintext highlighter-rouge">Show</code> interface, and so for each type there must exist a <code class="language-plaintext highlighter-rouge">Show</code> instance.</p> <p>The rest of the function is the same as before, except we compose each <code class="language-plaintext highlighter-rouge">f</code> with <code class="language-plaintext highlighter-rouge">pure . traceValBy show</code> to print the value we just computed.</p> <div class="language-idris highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">RunTraceM :</span> <span class="nc">Monad </span><span class="n">m</span> <span class="o">=&gt;</span> <span class="p">(</span><span class="n">p</span> <span class="o">:</span> <span class="kt">Pipeline</span> <span class="p">(</span><span class="mf">2</span> <span class="o">+</span> <span class="n">n</span><span class="p">))</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">print</span> <span class="o">:</span> <span class="kt">All</span> <span class="kt">Show</span> <span class="n">p</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="kt">ImplM</span> <span class="p">{</span><span class="n">m</span><span class="p">}</span> <span class="n">p</span> <span class="o">-&gt;</span> <span class="kt">Vect</span><span class="o">.</span><span class="nb">head </span><span class="n">p</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="p">(</span><span class="kt">Vect</span><span class="o">.</span><span class="nb">last </span><span class="n">p</span><span class="p">)</span>
<span class="kt">RunTraceM</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="p">{</span><span class="n">print</span> <span class="o">=</span> <span class="p">[</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">]}</span> <span class="n">f</span> <span class="o">=</span> <span class="n">f</span> <span class="o">&gt;=&gt;</span> <span class="n">pure</span> <span class="o">.</span> <span class="n">traceValBy</span> <span class="n">show</span>
<span class="kt">RunTraceM</span> <span class="p">(</span><span class="n">x</span> <span class="o">::</span> <span class="n">y</span> <span class="o">::</span> <span class="n">z</span> <span class="o">::</span> <span class="n">xs</span><span class="p">)</span> <span class="p">{</span><span class="n">print</span> <span class="o">=</span> <span class="n">p</span> <span class="o">::</span> <span class="n">q</span> <span class="o">::</span> <span class="n">ps</span><span class="p">}</span> <span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="o">=</span>
  <span class="n">f</span> <span class="o">&gt;=&gt;</span> <span class="n">pure</span> <span class="o">.</span> <span class="n">traceValBy</span> <span class="nb">show </span><span class="o">&gt;=&gt;</span> <span class="kt">RunTraceM</span> <span class="p">(</span><span class="n">y</span> <span class="o">::</span> <span class="n">z</span> <span class="o">::</span> <span class="n">xs</span><span class="p">)</span> <span class="n">c</span>
</code></pre></div></div> <p>Calling our pipeline with <code class="language-plaintext highlighter-rouge">RunTraceM</code> will print out every intermediate value produced by the pipeline, It won’t print the first argument given to it but since we already have it, we can print it when we call the pipeline.</p> <h2 id="conclusion">Conclusion</h2> <p>There is much more to say about this but is already more than we can usually do without dependent types. We can take the pipeline and build multiple runtimes for it, and run it in multiple modes as well. I’ve not shown it here but we can also implement operations on the pipeline like concatenation, splicing, etc. Those operations should reflect what happens at runtime: Concatenating two pipeline should compose two programs that run them. This framework can be extended in many other ways but that will serve as a solid base for now, see you in the next one.</p> <p>The code is available as a library: https://gitlab.com/glaive-research/pipelines</p>]]></content><author><name></name></author><category term="dependent-types"/><category term="idris"/><category term="programming"/><category term="software-engineering"/><summary type="html"><![CDATA[Sometimes, writing a large program is conceptually as simple as translating from a big unstructured input into a more and more structured output. In this post, we present a data structure to talk about such programs and demonstrate its use and flexbility using a single-pass compiler as case-study.]]></summary></entry><entry><title type="html">Govan Active Travel</title><link href="https://andrevidela.com/blog/2024/govan-active-travel/" rel="alternate" type="text/html" title="Govan Active Travel"/><published>2024-11-29T04:14:00+00:00</published><updated>2024-11-29T04:14:00+00:00</updated><id>https://andrevidela.com/blog/2024/govan-active-travel</id><content type="html" xml:base="https://andrevidela.com/blog/2024/govan-active-travel/"><![CDATA[<p>This is a report building on the designs provided by the <a href="https://storymaps.arcgis.com/collections/c390337efca64158b725c0c99bf61f12">connecting greater govan project</a> to facilitate active travel through the Govan area and develop it economically and culturally.</p> <p>First I will present the governing idea that drives the feedback and then show 3 edited documents that detail in what way the street layout can be changed to achieve the goals presented. The final section makes a case against 2-way cycle lanes before concluding.</p> <h2 id="part-1--govan-cross-and-public-space">Part 1 : Govan Cross and Public Space</h2> <p>The first part of the feedback is to question the place of govan cross and the way it serves the community. As of today, Govan cross, and its main street govan road, serve as a carrier of through traffic, as well as a parking resource for non-residents.</p> <p>The goal of the following map is to transform the role of Govan Rd from a through-traffic road and parking spot, to a street that facilitates pedestrian access, wheelchair access, and cycling. With the aim to create more spaces for families, shops, and on-street activities like markets or events. All while allowing access to motor vehicles for people with mobility challenges, deliveries, and resident parking.</p> <p>This is achieved by creating a large pedestrian-only space at the core of Govan cross, allowing the streets to be decorated with trees, bushes and benches, and the extra space to be used for events, markets, and food stalls.</p> <ul> <li>Green is the pedestrian-only zone without motor vehicles</li> <li>Orange is the resident traffic access for motor vehicles</li> <li>Red is the through traffic for motor vehicles</li> </ul> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/govan-overview-480.webp 480w,/assets/img/govan-overview-800.webp 800w,/assets/img/govan-overview-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/govan-overview.jpeg" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p>This layout provides 4 opportunities for place-making, from east to west:</p> <h3 id="the-area-between-govan-subway-station-and-the-new-bridge">The Area Between Govan Subway Station and the New Bridge</h3> <p>The opening of the bridge towards Partick and the Riverside Museum is a great opportunity to revise the way visitors are expected to access it. As of today, once a visitor exits the subway station, they have to cross a busy road, often littered with parked cars, hindering visibility, to reach Water Row and cross the bridge. What is more, the space taken by the road prevents any future businesses from developing by capitalising on the additional foot traffic.</p> <p>Restricting access to vehicles between the station and water row greatly facilitates access to the bridge for people with mobility difficulties and creates an additional space for the community. Vehicle access to Water Row for residents, deliveries, and visitors is guaranteed by Burleigh St, which itself would become accessible via Golspie St.</p> <h3 id="the-area-in-front-of-the-pierce-institute">The Area in Front of the Pierce Institute</h3> <p>The Pierce Institute is an important community hub in Govan, but as of right now, it is only directly accessible by 4 parking spots in front of it. Pedestrian access is difficult due to the high speed at which vehicles traverse Govan Rd, and cycle access is non-existent. Pedestrianising the street ensures easy access from the subway station. It also creates a plaza where both the Pierce Institute and the William Pierce statue can stand on uninterrupted grounds. Finally, the place provides dignified access to the Old Govan Church, a building whose historical importance has been too long neglected.</p> <h3 id="the-area-in-front-of-the-lyceum">The Area in Front of the Lyceum</h3> <p>The Lyceum building is of great importance to the community, as the current plans to reclaim it can attest, and it is paramount that its surroundings reflect that. Today, the intersection in front of the lyceum building entirely yields to through traffic, ensuring that the perception of the lyceum building remains that of a curiosity on the side of the road rather than a place to be celebrated by the local community. Future plans should ensure that the area in front of the Lyceum building is a place for people. And is starts with creating that space for the people.</p> <h3 id="the-west-intersection-between-golspie-st-and-govan-rd">The West Intersection Between Golspie St and Govan Rd</h3> <p>Today, this intersection is a source of traffic delay, pedestrian confusion, and unsatisfactory road maintenance. It is clear that this intersection has failed to serve the local community. The proposal is to remove the intersection entirely, and employ the additional space for a plaza that would bring foot traffic to the surrounding businesses, and create a space for children and families to enjoy. The space could also host some food trucks to serve the workers of the area and markets for the residents on the weekend.</p> <h3 id="a-note-about-bus-access">A Note About Bus Access</h3> <p>This proposal removes 3 bus stops along Govan Rd. Those stops are currently served by the buses M23 and M26 from McGill. Instead of going through GovanRd, they will need to stop at the south of the subway station where the current x19 stop, and follow the same pattern of stops (Govan Interchange, Helen St, Govan Rd). This is, in fact, a good thing, since anyone going west, towards QUEH, currently, has to choose whether to bet on bus 23 to come in first and wait at the north bus stop on Govan Rd. Or bet on the x19 and wait at the south bus stop on Golspie St. By consolidating both bust stops, this coinflip goes away and everyone is guaranteed to board the fastest bus westward. Additionally, all buses now make use of the fast link, instead of getting stuck at traffic lights on Govan Rd. Finally, access to Govan Rd is not significantly hampered since the bus stops at the west and east remain relatively unchanged, the new bus stops would be at most 50m further. The Old Govan Church is the point of interest most affected by the removal since it loses the bus stop in front of it served by the 23 and 26. Thankfully, removing this bus stop only increases the walking time by 3m, to reach the stops currently served by the x19, it increases the foot traffic in front of the local businesses.</p> <h2 id="part-2-detailed-plans">Part 2: Detailed Plans</h2> <p>This section provides detailed changes to the proposed design in the form of edited plans. These changes explain how the above design goals can be achieved in practice. There are three plans tracing</p> <p>The plan to pedestrianise Govan creates multiple opportunities for people and businesses to use the space freely. It also fluidifies vehicle traffic by directing through traffic via Golspie St and removing traffic lights and sources of road conflict.</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/Govan-east-480.webp 480w,/assets/img/Govan-east-800.webp 800w,/assets/img/Govan-east-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/Govan-east.jpeg" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <h4 id="east-access-to-govan-rd">East access to Govan Rd</h4> <p>The east access of Govan Cross is rendered difficult due to multiple streets joining at slightly off angles. Currently, most of the space is used by the intersection between Govan Rd and Golspie St. The roads are wide, the traffic lights often induce jamming and crossing the intersection as a pedestrian and a cyclist is challenging.</p> <p>The new design aims to safely bring cycle traffic from Govan Rd to Orkney St, while enabling pedestrians to cross safely at multiple junctions. Vechicle traffic is also improved by removing traffic lights, using the expansive space at the interesection to build a roundabout, and allowing residents to access Napier Road and Govan Road, using the layout shown above.</p> <h4 id="govan-rd-and-the-town-centre">Govan Rd and the Town Centre</h4> <p>With the pedestrianisation of most of the town center, access to businesses, points of interests (Old Govan Church, Riverside Museum), and community destinations (Pierce Institute) is made easier than ever. The additional room creates space for adults to gather and kids to play. The lack of private vehicles guarantees easy access for delivery vehicles, emergency vehicles, and people with mobility difficulties. Bike lanes are pushed to the side to leave room for pedestrians and do not require any grade separation.</p> <h3 id="govanrdfairfield--west-access-to-govan-cross">GovanRd/Fairfield &amp; West access to Govan cross</h3> <p>Govan connects to its historical roots as a ship building neighborhood, but the current street layout makes accessing this history difficult and unpleasant. The core of the proposed layout is to provide a new public space obtained by removing the intersection with Golspie St and diverting through traffic away from the centre.</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/Govan-west-480.webp 480w,/assets/img/Govan-west-800.webp 800w,/assets/img/Govan-west-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/Govan-west.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <h4 id="govan-rd-west-intersection-with-golspie-st">Govan Rd West Intersection with Golspie St</h4> <p>This intersection, as of today, is unsatisfactory. The traffic signals create delays, the layout does not leave any room for cyclists or pedestrians, access to businesses is limited, and access to the fairfield museum is unpleasant by foot from the station due to the amount of noise and polluting traffic at the intersection.</p> <p>To address those shortcomings, the proposed design removes the intersection altogether, adds zebra crossings for bikes and pedestrians, and creates a new space for people to use and congregate. This space should boost access to local businesses by providing outdoor seating, space for play, and opportunities to develop new businesses like markets or food trucks. It also makes access to the Fairfield Heritage Museum by foot much more pleasant from the subway station and greatly increases access to businesses for pedestrians and cyclists. The added space can accommodate outdoor seating, food trucks or seasonal markets. The fastlink bus lane remains unaffected and the connection to Elder Park is seamless</p> <h4 id="elder-park-bike-lane">Elder park bike lane</h4> <p>The change is simple: move the lane to the south of the road so that cyclists can access the park without endangering themselves, or endangering pedestrians.</p> <h3 id="govan-rd-and-linthouse">Govan Rd and Linthouse</h3> <p>The final section of this feedback document concerns the Linthouse neighborhood and its connection to Govan Rd. The original design removes a much-needed bus lane, this proposal reinstates the bus land and explains how to make the south bike lane around Elder Park connect with the interchange.</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/linthouse-480.webp 480w,/assets/img/linthouse-800.webp 800w,/assets/img/linthouse-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/linthouse.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <h4 id="north-west-of-elder-park">North West of Elder Park</h4> <p>The large intersection at the northwest of Elder Park is notoriously difficult to navigate by bike. The proposed change simply takes into account the fact that the bike lane is now at the southmost lane of the street. It keeps the current road design for vehicles with 1 bus lane and 2 car traffic lanes. It also reinstates the fast link bus lane west of the exchange while keeping the proposed bike lane.</p> <h4 id="towards-queh">Towards QUEH</h4> <p>Further west, the bike lane merges with the bus lane for the duration of the bridge and the next block. This is due to space constraints on this specific stretch of the street, keeping the bus lane is of utmost importance given its connection to QEUH. The bike layout around Burghead Pl and Peninver Dr remains the same, with added traffic calming in the form of parking space allocated on alternating sides of the road. The bus lane is extended all the way to the intersection of Govan Rd With Moss Rd, again to avoid delays incurred by private vehicles when reaching the hospital.</p> <h2 id="general-concern-about-2-way-bike-lanes">General concern about 2-way bike lanes</h2> <p>One of the issues with 2-way cycle lanes, is that access to the points of interest are guaranteed only from one side of the road. If a cyclist wishes to access a business, or a building, across their designated cycle lane they have three choices, all of which are bad:</p> <ul> <li>Cross the road through oncoming traffic on both sides</li> <li>Cycle until reaching a crossing, cross and join the car lane on the opposite direction</li> <li>Cycle until reaching a crossing, cross, and join the pedestrian pavement.</li> </ul> <p>Those three situations are illustrated in the image that follows:</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2-way-cycle-lanes-480.webp 480w,/assets/img/2-way-cycle-lanes-800.webp 800w,/assets/img/2-way-cycle-lanes-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/2-way-cycle-lanes.jpeg" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p>In the first scenario, the cyclist will encounter 3 sources of conflict: Incoming cycle traffic, and two lanes of vehicle traffic. This is in the best-case scenario where there is no parking and only two car lanes. This outcome is the most direct and the most dangerous, failing to protect cyclists from motor vehicle traffic.</p> <p>In the second scenario, the cyclist does not encounter any conflicts but does not make use of the bike lane on the last stretch of the trip. While this is safer for the cyclist, it also questions the role of the bike lane as a tool to protect different modes of transit, since, in this case, the bike lane fails to protect the cyclist on their way to their destination.</p> <p>In the last scenario, the cyclist does not encounter any conflict either, however, it <em>creates</em> conflicts with pedestrian traffic that is now put in danger by the cyclist. Again this questions the role of the bike lane as a tool to protect multi-modal forms of transit. We built a bike lane to protect pedestrian from bikes, yet, they end up sharing the same space.</p> <p>In conclusion, 2-way cycle lanes excel when all the points of interest are gathered on the same side of the road. Whenever that is <em>not</em> the case, they fail at their role to protect the users of the street. The proposed plans keeps 2-way bike lanes along Elder Park and in the Linthouse area because all the points of interest are on the same side. But it would be nice to eliminate 2-way cycle lanes in other parts of the designs proposed by Jacobs.</p> <h2 id="conclusion">Conclusion</h2> <p>Thank you for your time and for your work. I am optimistic that the changes to come in Govan are for the better, and I hope that this piece of feedback can help the area reach its potential as a historically important part of Glasgow and as a centre for cultural activities.</p>]]></content><author><name></name></author><category term="pedestrian"/><category term="space"/><category term="place-making"/><category term="cycle"/><category term="lane"/><category term="bike"/><summary type="html"><![CDATA[A new proposal for Govan Active Travel strategy]]></summary></entry></feed>